* Lecture: 1

** What weâ€™ll learn by the end of the course

- Computational thinking
  Write small pieces of code that do useful things

- Understand code written by others
  It is super useful to read code written by others

- Understand our abilities and limit
  Take description of a problem, and convert it into a programming problem

** Computation

 - Declarative knowledge
   - Tells you what something is, not how to do it
   - Closest it gets is allow us to test it
   e.g
   #+BEGIN_EXAMPLE
   \sqrt{x} is a number ~y~ s.t y^2 = x and y != 0
   #+END_EXAMPLE

  - Imperative knowledge
   - Tells us how to do something
   - A sequence of instructions to do something
   e.g
   #+BEGIN_EXAMPLE
   - Start with a guess ~g~
   - If g^2 = x, stop, return g
   - else g = (g + x/g) / 2
   - repeat
   #+END_EXAMPLE

  - *Computation* is about capturing the process of coming up with imperative process to do something
  -  A computation is based on a fixed set of primitives which are used to create complex computation

** Programming Language

- There is no best programming-language, but some language are better at doing certain things than
  other languages

- Language used in this course Python, but the course is not about Python. It is about how to program,
  Python is only a programming language choice and once we know how to code in one language, we can learn
  a new language easily

- Different dimensions of a languages
  - High vs Low level
    Low level: Very close to hardware. Primitives are moving data from one location in memory to high
    level: Much richer set of primitives

- General vs targeted
  General:For general purpose programming. Can be used to do a lot of things e.g Python Targeted: Designed
  for a specific purpose, e.g Math

- Interpreted vs Compiled

  Interpreted: Interpreter work directly on source-code at runtime Compiled: Compiler code to
  intermediate from (Object code) which actually runs finally

- Python is
  - High level
  - General Purpose
  - Interpreted

- *Static semantics*: which programs are meaningful

- *Semantics*: relating to meaning in language or logic

- *Syntax*: what are legal expressions in language


* Lecture: 2

- Two things needed to write programs:
  - Representing data
    - Value and Type

  - Give instructions to manipulate that data
    - Expressions: operands and operators

  - Type Conversion: conversion of data types
    - e.g
      #+BEGIN_SRC python
      str(3) + 'bf'  # it prints 3bf
      #+END_SRC

  - Type Checking: Python checks the type of the operands before it applies things

** Operator Precedence
   - Exponentiation are done before you do multiplication & divison done before you do addirion & subtraction
   - If use /parentheses/ the calculation happened in parentheses before the other operator
     e.g
     #+BEGIN_SRC python
     print(3+4*5) # its gonna be 23
     #+END_SRC
     There is other version with *Parenthese*
     #+BEGIN_SRC python
     print((3+4) * 5) # it should be 35
     #+END_SRC

  - *Variables*: have own values
    - They are created assignment statement
      e.g
      #+BEGIN_SRC python
      print(s = 3 + 5) # it create a link from that name to value
      #+END_SRC
    - In python variable type is dynamic
      - Dynamic means it chnges depending on what the current value is
    - Use variable any place where you want to use value
    - Use variable names that make sense

  - *Colon*: Identifies a block of code

  - *Statements*: are legal commands that python can interpret such as print, assignment

  -*Straight line program*: It should be "program which executes in the sequence of instructions"

  - *Branching programs* is program that can change the order of instructions based on some test
    - That tast is usally a value of a variable
      e.g
      #+BEGIN_SRC python
      x = 15
      if (x/2) * 2 == x:
          print('Even')
      else:
          print('Odd')
      #+END_SRC

    - Indentation matters
      e.g
      #+BEGIN_SRC python
      x = 'j'
      if 'd' < x:
      print('Hello') # it gives you a error because of indentation
      #+END_SRC

    - *Iteratiion or Loops*: If condition is true, do something, but keep doing it till it ends


* Lecture: 3

**  Basic elements of programming

- *Data* It is a collection of information

  - Such as int, string and boolean

- *Operations*: It takes a data and create a new data

  - Such as addition, multiplication and boolean

- *Commands*: gives an a authoritative order

  - There are few command those we seen before assignment, input, condition, branches and loop


** Good programming style

 - Put comments in code to highlight what you are doing and it makes easy to debug

 - Type Discipline: that you should check the types of operands before apply operator to them

 - Variables Names: should tell the purpose of the variable

   - Choosing meaningful name for variable is very important

 - /Testing/ all possible branches through a piece of code

   -  Make sure all inputs give you an output

 - *Iterative programs*: when a process or sequence is repeated in a program
   - A common iterations are loop
    e.g
     #+BEGIN_SRC python
     x = 16
     ans = 0

     while ans * ans <= x:
       ans += 1

     print ans
     #+END_SRC

   - *Defensive Programming*: is that should behave in a consistent manner even in the case of unexpected conditions
     - if there is negative value or not a square number so we use defensive programming

        e .g
        #+BEGIN_SRC python
        ans = 0
        x = 16

        if x >= 0:

          while ans * ans < x:
          ans = ans + 1

          if ans * ans != x:
            print x ' is not a perfect square'
          else: print ans

       else: print x 'is a negative number'
        #+END_SRC

 - Exhaustive enumeration: it means go through all possible values of some parameter
   - Or in other words testing everything unit will find right answer

 - *For loop*: works on one elements at a time

 - *Tuple*: is an ordered sequence of elements

   - Tuple is immutable (it can not be changed)

   - Its representation is following a parameters
     #+BEGIN_EXAMPLE
     yo = (1, 3, 6, 8)
     #+END_EXAMPLE

 - Index starts from 0 in tuple, list, string and dictionary


* Lecture: 4

 - *Decomposition*: it is a way of putting structure onto code
   - Or in other words its a way of braking the code into modules
     - Modules can be reuse in multiple places

 - *Abstraction*: means give names to things
    So that the name captures the core of what a function or program does

   - In abstraction, we hide the details behind a name

   - *Return*: A return statement returns a value to the caller of the function


   - *Function*: capture a common pattern of computation

     - It breaks the code up into modules

     - Functions suppress the details

     - return statement has no meaning outside the function

     - Function blocks begin with the keyword def followed by the function name and parentheses ( )

     - Functions use local bindings means that function's code has no effect on outside's code

     - Local bindings do not affect any global bindings
       e.g
        #+BEGIN_SRC python
       def test_bindings():
         x = 3 # x binds to test_binding

         if x % 2 != 0:
           return x
       x = 8 # that is global binding. I has no effect on test_bindings's x
       #+END_SRC

     - *Doc string* It tell what that function do

   - *Recursion*:  is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems  until you get to a small enough problem that it can be solved
       e.g
       #+BEGIN_SRC python
         def is_palindrome(s, indent):
           print indent, 'Palindrome called with', s

           if len(s) <=1:
             print indent, 'About to return True from base case'
             return True
           else:
             ans = s[0] == s[-1] and is_palindrome(s[1:-1], indent * indent)
             print indent, 'About to return', ans
             return ans
       #+END_SRC


* Lecture: 5

 - *Arbitrary precision integers*: are large numbers
   - You can make numbers as big as you want them to
     e.g
     #+BEGIN_SRC python
     a = 2 ** 1000
     print a # it gonna print really really big numben
     #+END_SRC

 - *Float*: Programming languages represent what we think as real numbers

   - Float is short for floating piont
   - All programming languages represent numbers using the i triple e floating point
     - It stands for IEEE 754 floating piont
     - it is a variant of scientific notation
     - It represent very large numbens
   - We represent the numbens in the form of a mantissa and exponent
   - Represent a floating point number as a pair of a mantissa and an exponent
   - Newer use double equals to compare ploatig point

 - Integers can not enumerate all gueses

   - Because the reals are uncountables

 - *Successive Approximation*: is a method that tells each guess is better than the  previous guess

 - *Bi-section method* is the division of something into two equal parts

   - Then easily deterimne whether the answer lies to the left or the right
